# 1. 类型

## 1.1 数值类型
说明：由于以太坊中需要确定的状态变化，不允许有浮点数的存在，因为浮点数的计算精确度不能确定，占用空间比较小，可以直接赋值。
### a . 布尔型（bool）

运算符号：
	！：逻辑非。
	||：逻辑或。
	&&：逻辑与。

### b. 整数类型（int uint uint256等）

运算符号：正常的运算符号。

### c. 地址类型

- 普通地址：20字节的值。
- 可支付地址：多两个转账函数。

### d.定长字节数组

属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 `bytes1`, `bytes8`, `bytes32` 等类型。定长字节数组最多存储 32 bytes 数据，即`bytes32`

```solidity
// 固定长度的字节数组
bytes32 public _byte32 = "MiniSolidity"; 
bytes1 public _byte = _byte32[0]; //_byte32的第一个字节
```

### e. 枚举类型enum
枚举（`enum`）是 Solidity 中用户定义的数据类型。它主要用于为 `uint` 分配名称，使程序易于阅读和维护。它与 `C 语言` 中的 `enum` 类似，使用名称来代替从 `0` 开始的 `uint`


## 1.2 引用类型

说明：引用类型有数组与结构体。

### a. 数组
#### 数组内容
说明：`bytes`比较特殊，是数组，但是不用加`[]`。另外，不能用`byte[]`声明单字节数组，可以使用`bytes`或`bytes1[]`。`bytes` 比 `bytes1[]` 省gas。
- 定长数组：在声明时指定数组的长度。用`T[k]`的格式声明，其中`T`是元素的类型，`k`是长度，例如：
```solidity
// 固定长度 Array
uint[8] array1;
bytes1[5] array2;
address[100] array3;
```
- 不定长数组：在声明时不指定数组的长度。用`T[]`的格式声明，其中`T`是元素的类型，例如：
```solidity
// 可变长度 Array
uint[] array4;
bytes1[] array5;
address[] array6;
bytes array7;
```

- 声明数组的特殊情况：对于`memory`修饰的`动态数组`，可以用`new`操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：
```solidity
// memory动态数组
uint[] memory array8 = new uint[](5);
bytes memory array9 = new bytes(9);
```

#### 数组函数

- `length`: 数组有一个包含元素数量的`length`成员，`memory`数组的长度在创建后是固定的。
- `push()`: `动态数组`拥有`push()`成员，可以在数组最后添加一个`0`元素，并返回该元素的引用。
- `push(x)`: `动态数组`拥有`push(x)`成员，可以在数组最后添加一个`x`元素。
- `pop()`: `动态数组`拥有`pop()`成员，可以移除数组最后一个元素。
### b.结构体

#### 结构体的内容


#### 结构体的复制方式


## 1.3 映射类型（mapping）



# 2.数据存储位置


# 3.函数

